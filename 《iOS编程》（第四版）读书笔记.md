# 《iOS编程》（第四版）读书笔记

## 对象

>`类（class）:` 制造对象的模子。

>通过类可以创建特定的对象，这些对象都是类的实例（instance）。

>所有的对象，都是内存中的一块数据。对象通过实例变量（instance variable）保存属性的值。

## 使用对象

>要使用某个类的对象，必须先得到一个指向该对象的变量（variable）。这类`指针变量`保存的是对象在内存中的地址，而不是对象自身。

### 创建对象

> 对象是有生命周期的：首先被创建出来，然后接收消息，最后在不需要时被释放。

向某个类发送alloc消息，可以创建该类的对象。 类在收到alloc消息后，会在内存中创建对象（在堆上创建，和调用malloc函数的效果相同），并返回指向新对象的指针。对新创建的对象，必须先向其发送一个初始化消息。在完成初始化之前，新创建的对象还无法正常工作。

### 发送消息

在Objective-C中，方法的唯一性取决于方法名。即使参数类型或返回类型不同，一个类也不能有两个名称相同的方法。

>`方法`和`消息`的区别：方法是指一块可以执行的代码，而消息是指要求类或对象执行某个方法的动作。
此外，消息的名称和将要执行的方法的名称一定是相同的。

### 释放对象

将指向对象的变量设置为nil，可以要求程序释放该对象。

>`nil`是值为0的指针，一个值为nil的指针通常代表没有指向任何对象。Objective-C允许向某个值为nil的变量发送消息，且不会发生任何事情。

## 异常与未知选择器
在运行时，当某个对象收到消息后，会根据创建该对象的类，执行和相应消息相匹配的方法。

Objective-C对象都有一个名为`isa(is a)`的实例变量。对象可以通过自己的isa知道自身的类型。

类在创建了一个对象后，会为新创建的对象的isa实例变量赋值，将其指回自己（即创建该对象的类）。

对象只能响应（respond）类（isa指向的类）中具有相应实现方法的消息。

## 通过ARC管理内存

### 栈（Stack）
当程序执行某个方法（或函数）时，会从内存中名为**栈（stack）**的区域分配一块内存空间，这块内存空间称为帧（frame）。帧负责保存程序在方法内声明的变量的值。在方法内声明的变量称为**局部变量（local variable）**。

当某个应用启动并运行**main**函数时，它的帧会被保存在栈的底部。当**main**调用另一个方法（或函数）时，这个方法（或函数）的帧会压入栈的顶部。被调用的方法还可以再调用其他方法，以此类推，最终会在栈中形成一个塔状的帧序列。当被调用的方法（或函数）结束时，程序会将其帧从栈顶“弹出”并释放。如果同一个方法再次被调用，则应用会创建一个全新的帧，并将其压入栈的顶部。

### 堆（Heap）
**堆（heap）**是内存中的另一块区域，和栈是分开的。 为这两类内存区域分别取名堆和栈，是为了能够形象地描述这两个概念。 栈会按后进先出的规则保存一组帧，而堆则包含了大量无序的活动对象，需要通过指针来保存这些对象在堆中的地址。

当应用向某个类发送**alloc**消息时，系统会从堆中分配出一块内存，其大小足够存放相应对象的全部实例变量。

## 指针变量（Pointer Variable）与对象所有权（Object Ownership）

指针变量暗含了对其所指向的对象的**所有权**（ownership）。

* 当某个方法（或函数）有一个指向某个对象的局部变量时，可以称该变量**拥有**该变量所指向的对象。
* 当某个对象有一个指向其他对象的实例变量时，可以称该对象拥有该实例变量所指向的对象。

## 强引用与弱引用（Strong and Weak References）

> *强引用循环（strong reference cycle，有时也称保留循环）*，当两个或两个以上的对象相互之间有强引用特性的指针关联时，就会产生强引用循环。 强引用循环会导致内存泄露。

要解决强引用循环问题，需要将两个对象之间的某个指针改为弱引用特性。

在决定将哪个指针改为弱引用前，可以先为存在强引用循环问题的多个对象决定相应的父-子关系。

确定父-子关系后，就可以让父对象拥有子对象，并确保子对象不会拥有父对象。

具有弱引用特性的指针指向的对象被释放后，指针会自动设置为nil。

## 属性特性

	@property (多线程特性, 读/写特性, 内存管理特性) 属性类型 属性名称;
	
### 多线程特性（Multi-threading attribute）

1. **nonatomic**
2. **atomic** （默认）

### 读/写特性（Read/write attribute）

1. **readwrite** （默认）
2. **readonly**

### 内存管理特性（Memory management attribute）

1. strong（指向Objective-C对象的属性的默认值）
2. weak
3. copy
4. unsafe_unretained（非对象属性的默认值）

对于**不指向任何对象**的属性，不需要做内存管理，这是应选用`unsafe_unretained`，它表示存取方法会直接为实例变量赋值。 *Apple引入ARC之前曾经使用assign表示这种类型*。

`unsafe_unretained`中的`unsafe`（不安全）是相对于弱引用而言。与弱引用不同，该类型的指针指向的对象被销毁时，指针不会自动设置为nil，而是成为空指针，因此不安全。

通常情况下，当某个属性是指向其他对象的指针，而且该对象的类有可修改的子类（例如NSString/NSMutableString或NSArray/NSMutableArray）时，应该将该属性的内存管理特性设置为copy。

`copy`属性的存方法可能类似于：

	- (void)setName:(NSString *) name
	{
		_name = [name copy];
	}
	
这样做的原因是，如果属性指向的对象的类有可修改的子类，那么该属性可能会指向可修改的子类对象，同时，该对象可能会被其他拥有者修改。因此，最好先复制该对象，然后再将属性指向复制后的对象。`copy`方法返回的是拥有强引用特性的指针。

## 属性合成

*在头文件中声明属性时，只会生成存取方法的声明。*为了让属性生成实例变量并实现存取方法，该属性必须被合成（synthesized）。通常情况下，编译器会自动合成属性并生成默认的实例变量和存取方法。如果需要自定义属性的合成方式，可以在实现文件中使用@synthesized指令：

	@implementation Person
	// 创建存取方法，方法名是age和setAge:,
	// 同时创建实例变量_age
	@synthesized age = _age;
	@end
	
以上代码与编译器自动合成的效果相同。赋值号左边的age表示需要创建存取方法，方法名是**age**和**setAge:**。右边的_age表示需要创建实例变量，变量名为_age。

也可以不写变量名，这样实例变量的变量名会和方法名相同：

	@synthesized age;
	// 和以下语句效果相同：
	@synthesized age = age;