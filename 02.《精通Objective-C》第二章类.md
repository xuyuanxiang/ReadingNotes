# 第二章
## 2.1 类接口
语法
```Objective-C
@interface ClassName : SuperclassName
// 属性和方法的声明
@end
```
## 2.2 实例变量
>实例变量是指为类声明的变量，它们在相应类实例（即对象）的生命周期中存在并拥有值。当对象被创建时，系统会为实例变量分配内存，当对象被释放时，系统也会释放变量占用的内存。实例变量拥有与对象对应的作用范围和命名空间。

访问控制编译器指令：`@private` `@protected` `@public` `@package`。

实例变量声明语法
```Objective-C
@implementation ClassName
{
	// 声明实例变量的代码
}
...
@end
```

## 2.3 属性
>属性与实例变量的区别是，属性无法直接访问对象的内部状态，但提供了访问这类数据的方便机制（即读取和设置方法），因而可以含有其他逻辑。

### 2.3.1 属性声明

```Objective-C
@property (特性) 属性类型 属性名;
```

#### 属性的特性

|类别    |           特性        |            描述     |
|---------|------                   |                 ------|
|原子性|nonatomic|使用该特性可以在多线程并发的情况中，将访问器设置为非原子性的，因而能够提供不同的结果|
|设置器语义|assign |**默认设置**，可以在不使用copy和retain特性的情况下，使属性得设置器方法执行简单得赋值操作。|
|设置器语义|retain |在赋值时，输入值会被发送一条保留消息，而上一个值会被发送一条释放消息|
|设置器语义|copy |在赋值时，输入值会被发送一条新消息的副本，而上一个值会被发送一条释放消息|
|设置器语义|strong |当属性使用ARC内存管理功能时，该特性等同于retain属性|
|设置器语义|weak |当属性使用ARC内存管理功能时，该特性的作用与assign特性类似，但如果引用对象被释放了，属性的值会被设置为nil|
|可读写性|readwrite|**默认设置**，使用该属性时，属性可以被读取也可以被写入，而且必须实现getter和setter方法。|
|可读写性|read-only|使用该特性时，会将属性设置为只读。必须实现getter方法。|
|方法名称|getter=getterName|重命名getter读取器的名称|
|方法名称|setter=setterName|重命名setter设置器的名称|

### 2.3.2属性定义

#### 显示定义
使用这种方法定义属性时，应在相应的类实现部分中明确定义属性的方法。例如：
```Objective-C
-(void) setMyIntProperty:(int) value
{
	_myIntProperty = value;
}
```

#### 通过关键字补全
通过使用`@synthesize`关键字，可以使编译器自动生成属性定义。属性代码会在相应的类实现部分中被自动补全。
```Objective-C
@synthesize 属性名称 [=实例变量名称]
```
*如果省略了可选项`[=实例变量名称]`，编译器会根据属性实例变量标准命名惯例，自动生成实例变量的名字。*

#### 自动补全

`Clang/LLVM(4.2及更高版本)`是苹果公司推荐使用的Objective-C编译器，它支持对已声明属性进行自动补全。

编译器可以自动补全以下已声明的属性：

1. 没有使用关键字（如@synthesize）进行补全的属性；
2. 不是（通过@dynamic属性指令）动态生成的属性；
3. 没有用户编写的getter和setter方法的属性。

#### 动态生成
属性的访问器方法可以在运行时被委托或动态创建。使用`@dynamic`属性指令可以**阻止**编译器通过这种方式自动生成访问器方法。

### 2.3.3 由属性支持的实例变量
大多数属性都是由实例变量支持的，属性通过这种机制隐藏对象的内部状态。除非专门设置，否则实例变量应拥有与属性相同的名称（但会带下划线前缀）。

###  2.3.4 访问属性
+ 用于读取值的方法（getter方法）拥有与属性相同的名称；
+ 用于设置值的方法（setter方法），其名称以set开头、后跟首字母大写的属性名。

访问器方法:
```Objective-C
[myObject color];
[myObject setColor:输入值];
```
点语法：
```Objective-C
myObject.color;
myObject.color = 输入值;
```
**一般而言，应使用以上两种机制访问属性。**

**然而，如果与属性关联的对象还没有完全创建好时，不能使用这两种机制，而应该使用支持属性得实例变量。如：类内部的init方法和dealloc会直接访问实例变量。**

## 2.4 方法
> 方法定义了类和类实例（对象）在运行时展示的行为。它们直接与Objective-C类（类方法）或对象（实例方法）关联。实例方法能够直接访问对象的实例变量。可以在接口、协议或分类中声明方法，而已声明得方法的定义位于相应的类实现部分。

### 2.4.1 语法

```Objective-C
+ (id) hydrogenWithProtons: (unsigned) np neutrons: (unsigned) nn
```
**方法类型标识符**：

+ **类方法**由`+`表示，该方法拥有类的作用范围，这意味着它使用类级的操作并且无法访问类的实例变量（除非这些变量被当做参数传给它）。
+ **实例方法**由`-`表示，该方法拥有对象的作用范围，这意味着它使用实例级的操作，并且可以（根据实例上设定的访问控制）直接访问对象及其父对象的实例变量。

## 2.5 协议
> 使用协议声明的方法和属性可以由任何类实现。类接口直接与特定的类关联，因此也会直接与类的层次结构关联。相对而言，协议不与特定的类关联，因此使用它可以捕捉无继承关系的类之间的相似之处。协议使Objective-C支持多重继承规范得概念（方法声明）。协议还可以用于定义对象能够发送哪些消息（通过设置遵守协议的属性）。

声明协议：
```Objective-C
@protocol  协议名称
// 属性声明
@required
// 方法声明
@optional
// 方法声明
@end
```
**@required**后跟方法名，可以将方法标记为**必选方法**；

**@optional**后跟方法名，可以将方法标记为**可选方法**，可选方法不是协议必须实现的方法。

未使用以上两个关键字，默认设置为**必选方法**。

----

合并其他协议：
```Objective-C
@protocol 协议名称<协议名称>
// 方法声明
@end
```
通过在尖括号中设置已声明协议的名称，可以使一个协议与其他协议合并—这称为**接受协议**。**可使用逗号分隔多个协议**。

接口接受协议：
```Objective-C
@interface 类的名称:父类的名称<协议名称>
// 方法声明
@end
```

## 2.6 分类
> 使用分类可以在不进行子类化的情况下，为已经存在的类增加功能。分类中的方法会成为类的组成部分（在程序中），并且会被其子类继承。这意味着可以向这个类（或它的子类）发送消息，调用在分类中定义的方法。

分类通常用于：

1. 扩展其他人定义的类（即使无法访问它们的源代码）；
2. 替代子类；
3. 将新类的实现代码分发给多个源文件（通过多人分工，简化大型类的开发工作）。

```Objective-C
@interface 类的名称(分类名称)
// 方法的声明
@end
```

### 扩展
>可以将扩展视为一种匿名（即未命名的）分类。 在扩展中声明的方法必须在相应类的主@implementation块中实现（它们无法在分类中实现）。

```Objective-C
@interface 类的名称()
{
	// 实例变量的声明
}
// 属性的声明
// 方法的声明
@end
```
**扩展与分类的区别**是它能够声明实例变量和属性。

编译器会检查在扩展中声明的方法（和属性）是否被实现。

**类扩展通常应存储在类实现文件中，并用于组织和声明在类中独立使用的其他私有方法**（例如，不是公用API的一部分）。

