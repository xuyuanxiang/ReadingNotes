HTML (Hypertext Markup Language)
=================================

> 用HTML标记内容的目的是为了赋予网页**语义（semantic）**。换句话说，就是要给你的网页赋予某些**用户代理（user agent）**能够理解的含义。

***用户代理***：*平时用的浏览器、给视障用户朗读网页的屏幕阅读器，以及搜索引擎放出的Web爬虫……*

##块级（block）和行内（inline）标签

### 块级标签：

```HTML
<h1>-<h6>: 6级标签，<h1>表示最重要
<p>: 段落
<ol>: 有序列表
<li>: 列表项
<blockquote>: 独立引用
```
### 行内标签：

```HTML
<a>: 链接（anchor，锚）
<img>: 图片
<em>: 斜体
<strong>: 重要
<abbr>: 简写
<cite>: 引证
<q>: 文本内饮引用
```
> 几乎所有的HTML元素的display属性值要么为block，要么为inline。 最明显的一个例外是table元素，它有自己特殊的display属性值。

> **块级元素**（block）会相互堆叠在一起沿页面向下排列，每个元素分别占一行。**块级元素盒子会扩展到与父元素同宽。**

> **行内元素**（inline）会相互并列，只有在空间不足以并列的情况下才会折到下一行显示。**行内元素盒子会“收缩包裹”其内容，并且会尽可能包紧。**

CSS工作原理
==============================

## 伪类

+ __UI（User Interface，用户界面）伪类__会在HTML元素处于某个状态时（比如鼠标指针位于链接上），为该元素应用CSS样式。
+ __结构化伪类__会在标记中存在某种结构上的关系时（如某个元素是一组元素中的第一个或最后一个），为相应元素应用CSS样式。

### UI伪类

#### 1. 链接伪类
+ __Link__。此时，链接就在那儿等着用户点击。
+ __Visited__。用户此前点击过这个链接。
+ __Hover__。 鼠标指针正悬停在链接上。
+ __Active__。 链接正在被点击（鼠标在元素上按下，还没有释放）。

**由于这4个伪类的特指度相同，如果不按照这里列出的顺序使用它们，浏览器可能不会显示预期结果。**

#### 2. :focus伪类
```css
e:focus
```
#### 3. :target伪类
```css
e:target
```

### 结构化伪类

#### 1. :first-child 和 :last-child
```css
e:first-child
e:last-child
```
#### 2. :nth-child
```css
e:nth-child(n)
```
_`n:`表示一个数值（也可以使用`odd`或`even`）_

## 伪元素

### 1. ::first-letter伪元素
```css
e::first-letter
```
### 2. ::first-line伪元素
```css
e::first-line
```
### 3. ::before 和 ::after伪元素
```css
e::before
e::after
```

## 继承
> CSS中有很多属性是可以继承的，其中相当一部分都跟文本有关，比如颜色、字体、字号。然后，也有很多CSS属性不能继承，因为继承这些属性没有意义。这些不能继承的属性主要涉及元素盒子的定位和显示方式，比如边框、外边距、内边距。

## 层叠
> 层叠，就是层叠样式表中的层叠，是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值的多个来源，确定最终使用哪个值。

### 样式来源
1. 浏览器默认样式表
2. 用户样式表
3. 作者链接样式表（按照它们链接到页面的先后顺序）
4. 作者嵌入样式
5. 作者行内样式

浏览器会按照上述顺序依次检查每个来源的样式，并在有定义的情况下，更新对每个标签属性值的设定。整个检查更新过程结束后，再将每个标签以最终设定的样式显示出来。

###层叠规则
#### 层叠规则一：找到应用给每个元素和属性的所有声明。
浏览器在加载每个页面时，都会据此查到每一条CSS规则，标识出所有受到影响的HTML元素。

#### 层叠规则二：按照顺序和权重排序
浏览器依次检查5个来源，并设定匹配的属性。如果匹配的属性在下一个来源也有定义，则更新该属性的值，如此循环，直到检查完页面中所有标签受影响属性的全部5个来源为止。最终某个属性被设定成什么值，就用什么值来显示。

#### 层叠规则三：按特指度排序。

#####计算特制度：
`I-C-E`：三个字母间的短横线是分隔符，计算方法如下：

1. 选择符中有一个ID，就在I的位置上加1；
2. 选择符中有一个类，就在C的位置上加1；
3. 选择符中有一个元素（标签）名，就在E的位置上加1；

*`0-1-12`与`0-2-0`相比，`0-2-0`的特指度更高*

#### 层叠规则四：顺序决定权重。
如果两条规则都影响某元素的同一个属性，而且它们的特指度也相同，则位置最靠下（或后声明）的规则胜出。

> #简单层叠要点
> **规则一：**包含ID的选择符胜过包含类的选择符，包含类的选择符胜过包含标签名的选择符。（ID > class > element）。

> **规则二：**如果几个不同来源都为同一个标签的同一个属性定义了样式，行内样式胜过嵌入样式，嵌入样式胜过链接样式。在链接的样式表中，具有相同特指度的样式，后声明的胜过先声明的。

> *规则一**胜过**规则二。换句话说，如果选择符更明确（特指度更高），无论它在哪里，都会胜出。*

> **规则三：**设定的样式胜过继承的样式，此时不用考虑特指度（即显式设定优先）。

规则三示例：
```HTML
<div id="cascade_demo">
	<p id="inheritance_fact">Inheritance is <em>weak</em> in the Cascade</p>
</div>
```
高特指度：2 － 0 － 2
```CSS
div#cascade_demo p#inheritance_fact {
	color:blue;
}
```
低特指度：0 －0 －1
```CSS
em {
	color:red;
}
```
`em`会变成红色。  *`em`继承的颜色值，会被为它明确（显式）指定的颜色值覆盖，就算（隐式）继承的规则特指度高也没有用。*

## 规则声明

### CSS属性值

#### 文本值
所有CSS属性都有文本值。

#### 数字值
数字值用于描述元素的各种长度（在CSS里，“长度”的含义比较广，还包括高度、宽度、粗细，等等）。**数字值主要分两类：绝对值和相对值**。

绝对值及示例：

|绝对值|单位缩写|示例|
|----------|-----------|------|
|英寸|in|height:6in|
|厘米|cm|height:40cm|
|毫米|mm|height:500mm|
|点|pt|height:60pt|
|皮卡|pc|height:90pc|
|像素|px|height:72px|

相对值及示例：

|相对值|单位缩写|示例|
|----------|-----------|------|
|Em|em|height:1.2em|
|Ex|ex|height:6ex|
|百分比|%|height:120%|

`em`和`ex`都是字体大小的单位，但在CSS中，它们作为长度单位适用于任何元素。

`em`：表示一种字体中字母M的宽度，具体大小取决于使用的字体。

`ex`：等于给定字体中字母x的高度（小写字母x代表一种字体的字母中间部分的高度，不包括字母上、下突出的部分——如d和p上下都出头）

`百分比`非常适合设定被包含元素的宽度。

# 定位元素
+ **position属性：**控制页面上元素间的位置关系。
+ **display属性：**控制元素是堆叠、并排，还是根本不在页面上出现。
+ **float属性：**提供控制的方式。

## 盒模型

+ 边框（border）
+ 内边距（padding）
+ 外边距（margin）

### 垂直外边距叠加：
上下外边距相遇时，它们就会相互重叠，直至一个外边距碰到另一个元素的边框为止。
```CSS
p {
	margin-top: 50px;
	margin-bottom: 30px;
}
```

```HTML
<p></p>
<p></p>
```
第一段的下外边距与第二段的上外边距相邻，**实际间距**是`50px`，而不是`50+30px`。

`叠加只是垂直外边距，水平外边距不叠加。`对于水平响铃的元素，它们的水平间距是相邻外边距之和。

### 盒模型结论一 ：（没有宽度的盒子）
没有设置宽度的元素（宽度具有默认的auto值）始终会扩展到填满其父元素的宽度为止。添加水平边框、内边距和外边距，会导致内容宽度减少，减少量等于水平边框、内边距和外边距的和。

### 盒模型结论二：（有宽度的盒子）
 为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的width属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。
 
> CSS3新增了一个box-sizing属性，通过它可以将有宽度的盒子也设定成具有默认的auto状态下的行为。

## 浮动与清除
### 围住浮动元素的三种方法
> 说的形象一点，


